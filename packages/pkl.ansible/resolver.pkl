open module providers

extends "playbooks.pkl"

import "@utils/utils.pkl" as utils

import "tasks/base.pkl" as tasks_base

import "roles/base.pkl" as roles_base
import "roles/package.pkl" as roles_package
import "roles/packages.pkl" as roles_packages
import "roles/rpm.pkl" as roles_rpm
import "roles/rpms.pkl" as roles_rpms

open class Resolver {

  ansible_distribution = ""
  ansible_distribution_major_version = "0"
  yum_repo_enabled = false
  epel_release_enabled = false
  apt_repo_enabled = false

  // CheckRole returns true if the role can be used in the given context
  function CheckRole(role: roles_base.AnsibleRoleDefinition): Boolean =
    let (that = this)
    if (that.ansible_distribution == "CentOS" || that.ansible_distribution == "RedHat")
      if (that.yum_repo_enabled)
        (role is roles_package.AnsibleRoleDefinitionPackage) ||
        (role is roles_packages.AnsibleRoleDefinitionPackages) ||
        (role is roles_rpm.AnsibleRoleDefinitionRpm) ||
        (role is roles_rpms.AnsibleRoleDefinitionRpms)
      else
        (role is roles_rpm.AnsibleRoleDefinitionRpm) || (role is roles_rpms.AnsibleRoleDefinitionRpms)      
    else
      (role is roles_package.AnsibleRoleDefinitionPackage) || (role is roles_packages.AnsibleRoleDefinitionPackages)

  // GetRoles returns all the roles that are valid for the given context
  function FilterRoles(roles: Map<String, roles_base.AnsibleRoleDefinition>): Map<String, roles_base.AnsibleRoleDefinition> =
    let (that = this) roles.filter((k, v) -> CheckRole(v))

  // Map of role names to the capabilities they provide
  function MapRolesToCapabilities(roles: Map<String, roles_base.AnsibleRoleDefinition>): Map<String, List<String>> =
    roles.fold(Map(), (acc, k, v) -> acc.put(k, v.provides))

  // Map of capability name to the roles that provide that capability
  function MapCapabilitiesToRoles(roles: Map<String, roles_base.AnsibleRoleDefinition>): Map<String, List<String>> = roles.entries
    .fold(Map(), (result, entry) -> result + entry.value.provides.fold(Map(), (acc, c) -> acc.put(c, List())))
    .mapValues(
      (k1, v1) -> roles
        .filter((k2, v2) -> v2.provides.toList().contains(k1))
        .keys
        .sortWith((a, b) -> (a is roles_package.AnsibleRoleDefinitionPackage) || (a is roles_packages.AnsibleRoleDefinitionPackages))
    )

  // MapCapabilitiesToPreferredRole returns the preferred role for each capability
  function MapCapabilitiesToPreferredRole(roles: Map<String, roles_base.AnsibleRoleDefinition>): Map<String, String> =
    roles.entries
    .fold(Map(), (result, entry) -> result + entry.value.provides.fold(Map(), (acc, c) -> acc.put(c, List())))
    .mapValues(
      (k1, v1) -> roles
        .filter((k2, v2) -> v2.provides.toList().contains(k1))
        .keys
        .sortWith((a, b) -> (a is roles_package.AnsibleRoleDefinitionPackage) || (a is roles_packages.AnsibleRoleDefinitionPackages))
        .first
    )
  
  // Return Map of resolved dependencies for each roles
  function MapRolesToDependencies(roles: Map<String, roles_base.AnsibleRoleDefinition>): Map<String, List<String>> =
    let (
      filtered = this.FilterRoles(roles)
    )
    let (
      preferred = this.MapCapabilitiesToPreferredRole(filtered)
    )
    filtered
    .mapValues((k, v) ->
      (
        let (r = v.requires.getOrNull(ansible_distribution) ?? new Listing {})
        if (r is Mapping) (r.getOrNull(ansible_distribution_major_version) ?? new Listing {})
        else r
      )
      .toList()
      .map((x) -> preferred.getOrNull(x) ?? "Role "+x+" not available for ansible distribution "+ansible_distribution)
    )

  function CompactRoles(
    roles: List<AnsiblePlaybookRole>
  ): List<AnsiblePlaybookRole|String> = roles.map((role) -> role.compact())

  function GetTasksForNames(
    names: List<String>,
    definitions: Map<String, tasks_base.AnsibleTaskDefinition>
  ): List<tasks_base.AnsibleTaskDefinition> = names.map((name) -> definitions[name])

  function GetDefinitionsForRoles(
    roles: List<String|AnsiblePlaybookRole>,
    definitions: Map<String, AnsiblePlaybookRole>
  ): List<AnsiblePlaybookRole> = roles.map((role) -> if (role is String) definitions[role] else role)

  function ExpandRole(
    role: String|AnsiblePlaybookRole,
    dependencies: Map<String,  Function1|List<String>>,
    env: Map<String,String>
  ): List =
    let (that = this)
    if (role == null) (
      List()
    ) else (
      // If role is a string, then check dependencies
      if (role is String)
        if(dependencies.containsKey(role))
          that.ExpandRoles(
            (if(dependencies[role] is Function1) dependencies[role].apply(env) else dependencies[role]), dependencies, env
          ) +
          List(role)
        else (
          List(role)
        )
      else
        // Don't do dependency checking on fully defined roles
        List(role)
    )

  function ExpandRoles(
    roles: List<String|AnsiblePlaybookRole>,
    dependencies: Map<String, Function1|List<String>>,
    env: Map<String,String>
  ): List = let (that = this) roles.map((role) -> that.ExpandRole(role, dependencies, env))

  function GetRoleForCapability(
    names: List<String>,
    roles: Map<String, roles_base.AnsibleRoleDefinition>
  ): List<String> =
    this.MapCapabilitiesToPreferredRole(this.FilterRoles(roles)).getOrNull(name)

  function GetRolesForCapabilities(
    names: List<String>,
    roles: Map<String, roles_base.AnsibleRoleDefinition>
  ): List<String> =
    let (
      preferred = this.MapCapabilitiesToPreferredRole(this.FilterRoles(roles))
    )
    names.map((name) -> preferred[name])

  function RenderRoles(
      roles: List<String|AnsiblePlaybookRole>,
      role_definitions: Map<String, roles_base.AnsibleRoleDefinition>,
      role_references: Map<String,AnsiblePlaybookRole>,
      dependencies: Map<String, Function1|List<String>>,
      env: Map<String,String>): List<String|AnsiblePlaybookRole> =
      let (that = this)
      let (
        all_dependencies = dependencies.toMap() + that.MapRolesToDependencies(role_definitions)
      )
      that.CompactRoles(
        that.GetDefinitionsForRoles(
          utils.distinct(
            utils.flatten(
              that.ExpandRoles(roles, all_dependencies, env)
            )
          ),
          role_references
        )
      )
}

function NewResolver(ansible_distribution: String, ansible_distribution_major_version: String, yum_repo_enabled: Boolean, epel_release_enabled: Boolean): Resolver
  = new Mapping {
    ["ansible_distribution"] = ansible_distribution
    ["ansible_distribution_major_version"] = ansible_distribution_major_version
    ["yum_repo_enabled"] = yum_repo_enabled
    ["epel_release_enabled"] = epel_release_enabled
  }.toMap().toTyped(Resolver)

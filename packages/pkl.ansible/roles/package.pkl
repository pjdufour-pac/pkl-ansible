open module package

extends "base.pkl"

import "@utils/utils.pkl" as utils

// Import factory
import "../factory.pkl" as mod_factory

class AnsibleRoleDefinitionPackage extends AnsibleRoleDefinition {
    // Dependency Resolution
    provides = ((that) -> List(that.name)).apply(this)
    requires = new Mapping {}
    //
    defaults = ((that) -> new Mapping<String,unknown> {
        [utils.slugify(that.name)+"_state"] = "latest"
        [utils.slugify(that.name)+"_cacheonly"] = false
        [utils.slugify(that.name)+"_validate_certs"] = true
        [utils.slugify(that.name)+"_install"] = true
        when(selinux_module.length > 0) {
            [utils.slugify(that.name)+"_selinux_enable"] = true
            [utils.slugify(that.name)+"_selinux_module"] = selinux_module
        }
        when(service_names.length > 0) {
            [utils.slugify(that.name)+"_disabled"] = false
            when(service_socket_files.length > 0) {
                [utils.slugify(that.name)+"_socket_file"] = service_socket_file
            }
        }
        when((firewalld_services != null && firewalld_services.length > 0) || (ufw_ports != null && ufw_ports.length > 0)) {
            [utils.slugify(that.name)+"_update_firewall"] = false
        }
        for(_key, _value in extra_defaults) {
            [_key] = _value
        }
    }).apply(this)
    // Generate tasks
    tasks = this.post_tasks.apply(((that) -> new Listing<AnsibleTaskDefinition> {
        local factory = new mod_factory.Factory {}
        for(_task in that.pre_tasks) {
            _task
        }
        factory.yum.InstallYumPackage(that.name)
        factory.apt.InstallAptPackage(that.name)
        when(that.service_names != null && that.service_names.length == 1) {
            //factory.RenderServiceTemplates(that.name, that.service_templates)
            factory.service.StopService(that.name, that.service_names[0])
            factory.service.DisableService(that.name, that.service_names[0])
            when(that.service_socket_files != null && that.service_socket_files.length > 0) {
                factory.io.DeleteSocketFiles(that.name)
            }
            factory.service.RestartService(that.name, that.service_names[0])
            factory.service.EnableService(that.name, that.service_names[0]) 
        }
        when(that.service_names != null && that.service_names.length > 1) {
            //factory.RenderServiceTemplates(that.name, that.service_templates)
            factory.service.StopServices(that.name, that.service_names)
            factory.service.DisableServices(that.name, that.service_names)
            when(that.service_socket_files != null && that.service_socket_files.length > 0) {
                factory.DeleteSocketFiles(that.name)
            }
            factory.service.RestartServices(that.name, that.service_names)
            factory.service.EnableServices(that.name, that.service_names) 
        }
        when(that.firewalld_services != null && that.firewalld_services.length == 1) {
            factory.firewalld.AllowService(that.name, that.firewalld_services[0])
        }
        when(that.firewalld_services != null && that.firewalld_services.length > 1) {
            factory.firewalld.AllowService(that.name, that.firewalld_services)
        }
        when(that.ufw_ports != null && that.ufw_ports.length == 1) {
            factory.ufw.AllowPort(that.name, that.ufw_ports[0])
        }
        when(that.ufw_ports != null && that.ufw_ports.length > 1) {
            factory.ufw.AllowPorts(that.name, that.ufw_ports)
        }
    }).apply(this))
}

function NewAnsibleRoleDefinitionPackage(_name: String): AnsibleRoleDefinitionPackage =
    new AnsibleRoleDefinitionPackage {
        name = _name
    }

function NewAnsibleRoleDefinitionPackageOptions(_name: String, options: Mapping<String,unknown>): AnsibleRoleDefinitionPackage =
    (
        new AnsibleRoleDefinitionPackage {
            name = _name
        }.toMap() +
        options.toMap()
    ).toTyped(AnsibleRoleDefinitionPackage)